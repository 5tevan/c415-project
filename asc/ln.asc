# ASC for natural log
# How to call:
# - Place value (x) on stack
# - call 'ln_func'
# - x popped from stack
# - ln(x) pushed on stack
#
# Stack (from bottom):
# - x value
# - y value (answer)
# - n value (predefined, not visible to user)
# - counter (i=1 at start)
# - Tmp var for intermediate results

# Calculate ln using a mercator series expansion
ln_func

        PUSH -3[0]   # x
        CONSTR 0     # space for y
        CONSTR 1000  # max n (even, doesn't change,normally)
        CONSTR 1     # Start counter value, n=1 (3[0])
        ADJUST 1     # Intermediate var (4[0])
        CONSTR 1     # Counter var, i (5[0])

big_ln_loop
        # (x-1)
        PUSH 0[0] # Push x on stack
        DUP
        CONSTR 1 # Push 1 on stack
        SUBR # x-1 now on stack
        DIVR # x / (x-1)
        POP 4[0] # Place in interm. value

        PUSH 3[0]
        POP 5[0] # set i = n

        CONSTR 1
        PUSH 4[0] # push 'x' on stack

multiply_loop
        # raise some value to power n
        PUSH 5[0] # i
        CONSTR 1
        SUBR
        IFZ end_mult_loop
        PUSH 5[0]
        CONSTR 1
        SUBR
        POP 5[0] # i--
        
        PUSH 4[0]
        MULR
        
        GOTO multiply_loop

end_mult_loop
        # whatever is left on stack is answer...
        PUSH 3[0] # n on stack
        MULR # n * (x^n)
        DIVR # 1 / n*(x^n)
        PUSH 1[0]
        ADDR # add this to existing answer
        POP 1[0] # put current answer into 'y'
        PUSH 2[0] # grab max n
        PUSH 3[0] # grab current n
        SUBR # max n == n?
        IFZ endbiglnloop
        PUSH 3[0]
        CONSTR 1
        ADDR
        POP 3[0] # n++
        GOTO big_ln_loop


endbiglnloop
           
        ADJUST -4
        POP -3[0]
        ADJUST -1

        RET 0


