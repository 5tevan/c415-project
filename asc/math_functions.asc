# math_functions.asc
# Contents:
#  ln_func - ln(x)
#  exp_func - e^x
#  
#  Bonus Contents:
#   powercalc - x^y
#   factorialyo - x!


# ASC for natural log
# How to call:
# - Place value (x) on stack
# - call 'ln_func'
# - x popped from stack
# - ln(x) pushed on stack
#
# Stack (from bottom):
# - x value
# - y value (answer)
# - n value (predefined, not visible to user)
# - counter (i=1 at start)
# - Tmp var for intermediate results

# Calculate ln using a mercator series expansion
ln_func
        PUSH -3[0]   # x
        CONSTR 0     # space for y
        CONSTR 1000  # max n (even, doesn't change,normally)
        CONSTR 1     # Start counter value, n=1 (3[0])
        ADJUST 1     # Intermediate var (4[0])

big_ln_loop
        PUSH 0[0] # Push x on stack
        DUP
        CONSTR 1 # Push 1 on stack
        SUBR # x-1 now on stack
        DIVR # x / (x-1)
        POP 4[0] # Place in interm. value

# replace this with powercalc...
        PUSH 4[0]
        PUSH 3[0]
        CALL 0,powercalc
        ADJUST -1

        # whatever is left on stack is answer from pwrcalc
        PUSH 3[0]  # n (counter) on stack
        MULR       # n * (x^n)
        POP 4[0]   # store in tmp var
        CONSTR 1   # 1 on stack
        PUSH 4[0]  # n * (x^n) on stack
        DIVR       # 1 / n*(x^n)
        PUSH 1[0]  # current answer
        ADDR # add this to existing answer
        POP 1[0] # put current answer into 'y'
        PUSH 2[0] # grab max n
        PUSH 3[0] # grab current n
        SUBR # max n == n?
        IFZ endbiglnloop
        PUSH 3[0]
        CONSTR 1
        ADDR
        POP 3[0] # n++

        GOTO big_ln_loop

endbiglnloop

        ADJUST -3
        POP -3[0]
        ADJUST -1

        RET 0


# Exp fcn - using const for e
exp_func
        CONSTR 2.718281828459045235360287471352
        PUSH -3[0]
        CALL 0,powercalc

        ADJUST -1
        POP -3[0]
        RET 0


# powercalc - calculates some value x^n
# Stack order for values (bottom up): x, n
powercalc
        PUSH -4[0]      # x value
        PUSH -3[0]      # n value
        DUP             # LET i = n
        PUSH 0[0]        # interm. value

powercalcloop
        PUSH 2[0] # i
        CONSTR 1
        SUBR
        IFZ end_powercalc
        PUSH 2[0] # i
        CONSTR 1
        SUBR
        POP 2[0] # i--
        PUSH 3[0]       # get interm value
        PUSH 0[0]
        MULR
        POP 3[0]
        GOTO powercalcloop

end_powercalc
        POP -4[0]
        ADJUST -3

        RET 0


# Not really used for anything anymore...but here it is...
# (Maybe need it later for some other gymnastics?)
factorialyo
        PUSH 1[0] # current index val
        CONSTI 1 
        SUBI      # n-1
        DUP       # n-1
        IFZ donefactorial # if n=0, done here
        DUP
        POP 1[0]  # put decremented index back at 1[0]      
        PUSH 0[0] # current val
        MULI      # n-1 * current
        POP 0[0]  # put back

        GOTO factorialyo

donefactorial
        ADJUST -2
        POP -3[0]

        RET 0
